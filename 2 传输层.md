# 传输层 TCP, UDP, SCTP

- TCP三路握手
- TCP连接终止序列
- TCP的TIME_WAIT状态
- SCTP四路握手
- SCTP的连接终止
- 套接字层TCP，UDP，SCTP缓冲机制


> BSD分组过滤程序(BPF)是一种软件设备，用于过滤网络接口的数据流，即给网络接口加上开关。
> 数据链路提供者接口(DLPI)：提供对链路层的访问能力，随SVR4内核提供
> XTI

SCTP：可靠的传输协议

## 套接字分类

### 原始套接字

绕过传输层？（原始套接字）
分为 链路层原始套接字 和 网络层原始套接字
主要应用与底层网络编程

> 发送自定义的IP数据包
> 发送ICMP数据包
> 网卡的侦听模式，监听网络上的数据包
> 伪装IP地址
> 自定位协议的实现

-  链路层原始套接字

> 可以直接用于接收和发送链路层MAC帧，在发送时需要由调用者自行构造和封装MAC首部

- 网络层原始套接字

> 网络层原始套接字可以直接用于接收和发送IP层的报文数据
> 操作IP首部或传输层协议首部，就需要调用如下socket()函数创建网络层原始套接字

### 标准套接字

流式套接字和数据报套接字这两种套接字工作在传输层，主要为应用层的应用程序提供服务，并且在接收和发送时只能操作数据部分，而不能对IP首部或TCP和UDP首部进行操作。

原始套接字可以自动组装数据包（伪装本地IP和本地MAC），可以接收本机网卡上所有的数据帧（数据包）。另外，必须在管理员权限下才能使用原始套接字。

- 流式套接字
- 数据包套接字


## UDP，TCP，SCTP

TCP
	流量控制：通告窗口
SCTP
	面向消息的，提供各个记录的按序递送服务


## TCP连接建立

### 三路握手

```
1 server : socket , bind , listen
2 client :
	connect -> 客户端发送一个SYN段：告诉服务器客户将在连接中发送数据的初始序号。
	(connect block)
3 server :
	accept  -> 服务器确认ACK客户的SYN
			-> 服务器自己发送一个SYN段：服务器在这个连接中发送数据的初始序号。
	(accept block)
4 client :
	connect -> 客户端收到服务器的ACK和服务器的SYN，发送一个ACK对服务器的SYN确认
	(connect return)

5 server : 收到SYN
	(accept return)
```

### TCP选项

MSS：使用TCP_MAXSEG套接字选项提取和设置这个TCP选项

### TCP连接终止

```
1 c close -> FIN
2 s EOF->ACK
3 s FIN
4 c ACK
```



## TIME_WAIT

可靠地实现TCP全双工连接的终止

允许老的重复的分节在网络中消逝

为了防止在化身情况下收到之前的TIME_WAIT状态下发送的包，需要等待2MSL时间再建立相同的连接（一个是FIN分组MSL时间后另一个是应答分组经历MSL）



## SCTP关联的建立和终止

### 四路握手

1 服务器准备接受外来的关联 socket，bind，listen

2 客户端connect（此时sctp发送一个init消息）

​	INIT：IP地址清单、初始序列号、本关联的起始标记、客户请求的外出流的数目、客户能够支持的外来流的数目

3 服务器 INIT ACK

​	INIT ACK：IP地址清单、初始序列号、起始标记、客户请求的外出流的数目、客户能够支持的外来流的数目、**状态cookie**

状态cookie：经数字化签名，包含服务器用于确信本关联有效所需的所有状态

4 客户端 COOKIE ECHO：回射状态cookie，可能还捆绑了用户数据

5 服务器 COOKIE ACK：确认客户会社的cookie是正确的

作用：避免一种拒绝服务攻击

（相比TCP Cookie，SCTP提供了一个任意长度的字段）

### 关联终止

1 无“半连接”状态：一方关闭某个关联另一方必须停止发送新的数据，将数据发送完后关闭关联

2 无“TIME_WAIT”状态：因为使用了验证标记，所以只需要检验 验证标记即可



（接口式样？）



## TCP端口号与并发服务器

主机是多宿的：通配地址通过在调用bind之前把套接字地址结构中的IP地址字段设置成**INADDR_ANY**来指定



## 缓冲区大小以及限制

- IPv4数据报：最大65535字节，包括IPv4首部

- IPv6数据报：最大65575字节，包括40字节的IPv6首部。其中length字段只是表示数据取长度，16bit

  选项扩展成32bit

- MTU：可由网络硬件规定

  以太网：1500

  

  IPv4最小链路MTU：68字节

  IPv6最小链路MTU：1280字节

- path MTU、分片

  

- **最小重组缓冲区大小**

  是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。(应该是大家都支持的最大MTU？)

  IPv4位576字节，IPv6位1500字节。

  > 重组缓冲区的实际值由 MSS 间接指定，如果 MSS 为700字节，则**重组缓冲区的实际值**就是 MSS + TCP 头部 + IP 头部，即740字节，也就是一个最大的 IP 数据报的大小。但是如果对端未通告 MSS，则认为对端只支持最小重组缓冲区，因此默认 MSS 为536字节（IPv4 最小重组缓冲区大小576字节减去 TCP 和 IPv4 头部）。**一般重组缓冲区的大小和 MTU 是相等的。**

  

- MSS

  目的是：告诉对端其重组安魂冲去大小的实际值 （TCP/IP - 传输控制报文协议.md）

- SCTP_MAXSEG套接字选项



### TCP输出

每个TCP套接字有一个**发送缓冲区**，可以使用**SO_SNDBUF套接字选项**来更改该缓冲区大小。

当某个应用进程调用write时，内核从该应用**进程的缓冲区**中**复制**所有数据到**所写套接字的发送缓冲区**。

- 如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将进入睡眠（针对阻塞套接字）。直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区，write系统调用才返回。（这里应该时一般发送缓冲区都远远大于进程缓冲区中的数据量？）

  所以：write调用返回 -> 可以重新使用原来的应用进程缓冲区，但是对端并不一定已经收到数据

保留副本，被确认才丢弃。

### UDP输出

任何UDP套接字都有发送缓冲区大小（同样SO_SNDBUF），不过它**仅仅是可写到该套接字的UDP数据报的大小上限**。

若一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回进程一个EMSGSIZE错误。

在分组发送后，**保存在内核缓冲区**中的数据副本就被链路层丢弃了。

**写一个UDP套接字的write**调用成功**返回**表示：所写的数据报或其所有的片段**已被加入数据链路层的输出队列**。

### SCTP输出

它的套接字 有一个发送缓冲区，与TCP相同。

本端SCTP必须等待SACK。在积累确认点超过已发送的数据后，才可以从套接字缓冲区中删除。